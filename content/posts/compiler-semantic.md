---
title: 做个编译器——语义分析
date: 2022-06-16 15:13:06
tags: [笔记]
categories: []
summary: 为文法的每个产生式配上一个语义规则，在语法分析的过程中同时执行这些规则，实现一遍扫描



---



## 属性文法

### 属性

在上下文无关文法的基础上，为每个符号都附加上其相关的某些信息，称为属性。这些属性依附在所属的符号上面。

> 对属性进行加工，即进行语义分析。

### 语义规则

因为每个符号都附加了属性，所以每个产生式都附加了属性的计算、操作规则。

这些规则称为语义规则。

式`b:=f(c1,c2,...,ck)`给出了对语义规则的定义。所谓语义规则就是属性c1,c2,...通过运算f得到结果，把结果赋值给接受结果的属性b。

### 综合属性和继承属性

用于语法树中的自下而上（也就是产生式中的右部到左部）地传递信息。

体现在产生式上，应当根据产生式右部的符号的属性，可以**计算产生式左部符号的综合属性**。

体现在语法树上，也就是父节点的综合属性是由其孩子的属性进行计算得出的。

举例：`E->E1+T, E.val := E1.val + T.val`，则产生式左部的E有属性E.val，右部的E1和T分别有属性E1.val和T.val，那么左侧的E.val就是E的综合属性，它由右部的两个符号的属性相加计算而来。

> 因为综合属性需要几个已有的属性通过一定的计算才能得到其值，所以得名“综合”。

传递信息的方向和综合属性相反。

体现在产生式上，应当根据产生式左部的符号的或产生式右部其他符号的属性来**计算产生式右部符号的继承属性**。

举例：`L->L1, L1.in:=L.in`，那么产生式右部L1.in是通过产生式左部的L.in得到的。

举例：`D->TL, L.in = T.type`，那么产生式右部的T.type是通过产生式右部L.in得到的。

> 注意，从语义规则的角度来看，综合属性和继承属性的区别是：对于形如b:=f(c1,c2,...)的语义规则，是产生式左部的属性还是产生式右部的属性在赋值号(:=)左边。
>
> 注意，只能利用b来区分。切勿利用c1,c2,...是什么来区分。因为这不是重点。

### 带注释的语法树

把语法树的各结点用其语义规则进行替代，称为带注释的语法树。

<img src="https://linton-pics.oss-cn-beijing.aliyuncs.com/uPic/image-20220617144620011.png" alt="image-20220617144620011" style="zoom:33%;" />

带注释的语法树能清晰地反映信息传递的方向（自顶向下，自底向上）。

### addtype(id.entry, L.in)

在符号表中找到给定id的入口，并设定其类型信息为L.in。

<img src="https://linton-pics.oss-cn-beijing.aliyuncs.com/uPic/image-20220617145550570.png" alt="image-20220617145550570" style="zoom:33%;" />

### 属性依赖

之前提到，式`b:=f(c1,c2,...,ck)`给出了对语义规则的定义。

我们现在称b属性依赖于c1,c2,...,ck，当且仅当下面两种情况中的一种：

- 若b是综合属性，且c1,...,ck是产生式右部属性
- 若b是继承属性，且c1,...,ck是产生式右部属性，或综合属性

**实际上，上述这种定义就是又把综合属性、继承属性的定义说了一遍而已。**

> 换言之，只要存在语义规则上面的关系b:=f(c1,c2,...,ck)，就可以认为是b属性依赖于c1,c2,...,ck。

### 终结符只能有综合属性，其值需要由词法分析器给出

从产生式的角度来看：显然，终结符不可能有继承属性，因为它仅出现在产生式右部，但是它不会被赋值（因为输入串是只读的），而是只能参与运算，所以不可能存在继承属性。词法分析器负责给终结符赋予综合属性，例如如果是一个标识符，那么赋予其entry（符号表项入口地址）（注意，标识符的值是通过先找到符号表项的入口，再查看该表项得出）。这样它就能参与到运算中去，把自己的这个属性向上传递了。

从语法树的角度来看：终结符是只读的，所以不能被从语法树上方来（自上而下）的信息赋值，所以不存在继承属性。但是，为了让语义分析得以进行，这些叶结点应当被赋予可以向上传递的信息（即综合属性），这样上面才有事干。这个赋值的工作由词法分析器承担。

### 开始符号的综合属性的值需要事先给出

开始符号作为语法树的根，它没有父节点，所以无法计算得出综合属性的值。因此需要人为给他。

## 语法制导翻译

根据程序的语法结构进行驱动（例如语法树），在跑语法分析的时候顺便利用语义规则计算各结点的值（一遍扫描法），或进行语法翻译后得到了语法树，对该语法树执行语义规则（依赖图、语法树遍历法），称为语法制导翻译。

> 为文法的每个产生式配上一个语义规则，在语法分析的过程中同时执行这些规则即可。

语法制导翻译的主要算法有依赖图、语法树遍历、一遍扫描。

### 依赖图

<img src="https://linton-pics.oss-cn-beijing.aliyuncs.com/uPic/image-20220617154403427.png" alt="image-20220617154403427" style="zoom:25%;" />

如图是一个依赖图。它是基于注释语法树的。当计算得到注释语法树后，把语法树的每个结点的属性都构建结点，画在所属树结点的旁边，然后对于所有的这样的新结点，如果存在语义规则`b:=f(c1,c2,...,ck)`，则从b到c1,c2,..,ck画有向边，表示b依赖于c1,c2,...,ck。

如果依赖图构建完成后是无环的，那么这是一个良定义的语义规则。对于无环的图，我们可以求出其拓扑序。根据**拓扑序**依次对属性进行计算即可实现语法分析了。

但是语法树、依赖图建图、拓扑序计算都需要扫描，这是多遍扫描的算法，效率低。

### 树遍历

仍然是先得出注释语法树，然后以某种顺序（例如深度优先且从左到右）遍历该树，把能计算的属性都计算出来，计算不出的先空着，等到下一次遍历的时候再尝试计算。显然这也是一个多遍扫描算法。

递归进入之前，先计算递归对象所有可以计算出来的继承属性。进入了递归，对每个孩子结点从左到右依次进行这个操作（先算其继承，再进入它，再计算其综合）。递归返回之后，紧接着计算该递归对象的综合属性。

### 抽象语法树：一遍扫描

一遍扫描方法可以在进行语法分析的同时完成语义分析。也就是当语法树构造完毕，其所有结点的属性也都有了。

为文法的每个产生式配上一个语义规则，在语法分析的过程中同时执行这些规则即可。

<img src="https://linton-pics.oss-cn-beijing.aliyuncs.com/uPic/image-20220617160741664.png" alt="image-20220617160741664" style="zoom:33%;" />

如图是用于算术运算的一棵抽象语法树（AST）。它去除了对翻译（语义分析）没有必要的结点，而用算符（例如其中的+）来代表算式结果。特别地，AST的根是整个表达式的结果。

对于原产生式，每个符号都有属性nptr，即node pointer，指向一个结点的指针。

给出下面几个语义规则，用于建立AST。

- mknode(op,left,right)建立一个树结点，其子树left和right都是nptr。
- mkleaf(id,entry)，mkleaf(num,val)分别建立标识符（变量）结点和常量数字结点。因为标识符需要对应一段内存空间来存储其值，所以其第二个域是符号表项入口。

然后，对文法的每个产生式都编写一条语义规则，例如：

对产生式`E->E1+T`，附加语义规则`E.nptr:=mknode('+',E1.nptr,T.nptr)`。可以想象，这就建立了一棵加法子树。

## L属性文法的翻译

### S-属性文法和L-属性文法

如果所有的产生式给出的语义规则都只包含**综合属性**，那么这是一个S属性文法。

如果所有产生式，例如`A->X1X2...Xn`，其中的属性要么是综合属性，要么是满足“仅依赖于其左边符号的属性或产生式左部的属性”的继承属性。例如Xi有继承属性，那么该属性必须只依赖于X1,X2,...Xi-1符号或A的某些属性，而不能是Xi+1，...,Xn的。例如产生式`A->BC`,有语义规则`B:=f(C)`，那这就不满足L属性文法。

S属性文法一定是L属性文法。L属性文法是对S属性文法要求的进一步放松。

### 翻译模式

翻译模式是将语义规则朝着具体实现的方向的进一步改造。语义规则本身不带有执行顺序，它只是附带在产生式上的赋值表达式而已。这些表达的执行顺序由实际翻译过程给出，例如语法树的遍历顺序决定了他们的执行顺序。

![image-20220617164516720](https://linton-pics.oss-cn-beijing.aliyuncs.com/uPic/image-20220617164516720.png)

翻译模式把语义规则的执行顺序表现出来。 例如通过翻译模式，我们可以得知R的产生式的print操作应当在T扩展（或者说是匹配）完成，而没轮到R1扩展（或者说是匹配）的时候执行。但是语义规则就没法做到这么详细。

如图，翻译模式就是把语义规则用花括号括起来，插入到产生式的正确位置上去，从而赋予**执行的时机**信息。

<img src="https://linton-pics.oss-cn-beijing.aliyuncs.com/uPic/image-20220617165025025.png" alt="image-20220617165025025" style="zoom:33%;" />

例如如图的情况，可以看到语义规则的执行在树上以虚线表示。根据给出的翻译模式，每次num匹配了之后，就紧接着print；每次T展开已完成，R还没展开，此时中间会有个print。

### 设计翻译模式

对于综合属性，因为它需要产生式右部的符号的属性值，所以把它的语义规则放在右部末尾是最安全的，因为能保证这些值都计算完了。（当然如果能提前算完，其位置还能往前提）

非考点，其他要点略。

> 总之，翻译模式的设计过程，就是要决定要把语义规则插入到产生式右部的哪个位置上，才能保证其能被正确翻译（每次应用语义规则都不会引用到尚未计算出的属性值）
>

### L属性文法的自顶向下翻译

根据L文法的特点，它能保证在使用翻译模式进行自顶向下翻译时，每次应用语义规则都不会引用到尚未计算出的属性值。

## 中间语言

### 中间语言、前端和后端

<img src="https://linton-pics.oss-cn-beijing.aliyuncs.com/uPic/image-20220617171532412.png" alt="image-20220617171532412" style="zoom:25%;" />

中间语言是介于源语言和目标语言之间的一种语言，其描述的复杂程度介于二者之间。

因此，其是独立于机器的，可以做到从源语言看，把机器代码抽象化（透明化），从机器看，把源语言抽象画（透明化）。由此，我们称源语言到中间语言的过程是编译器的前端，中间语言到目标语言是后端，二者可以独立进行开发。

后端可以针对目标机器对同一种中间语言给出不同的优化，实现更优的适配。不同的机器有不同的后端，但是如果统一了中间语言，那么代码可以非常方便地进行移植。

### 常见的中间语言

- 后缀式表示的中间语言
- 图表示的中间语言
	- AST
	- DAG
- 三地址代码表示的中间语言
	- 三元式
	- 四元式
	- 间接三元式

### 后缀式中间语言

后缀式的构成原则（递归定义）

- 对于单独的标识符或常量，后缀式是其本身。
- 对于二元操作符op，形如A1opB1被表示为A2B2op。其中A2、B2分别是A1、B1的后缀式。
- 对于括号操作，例如(A)，那么其后缀式是A的后缀式。（因此可以看出，后缀式无需括号即可实现对任意运算顺序的无歧义表达。）

后缀式运算的代码实现

- 从左向右扫描后缀式，并维护一个值栈，每次遇到数值就push进去，每次遇到k目运算符就对栈顶的k个值进行计算并替换他们。

中缀式转后缀式的属性文法

- 这三条产生式对应了后缀式的三条递归定义。

<img src="https://linton-pics.oss-cn-beijing.aliyuncs.com/uPic/image-20220617174403629.png" alt="image-20220617174403629" style="zoom:25%;" />

- 代码实现如下。例如要归约`E -> E1 op E2`，那么认为现在POST的最大下标下分别已经是E1的后缀式和E2的后缀式了。因为他俩都归约完成了才能轮到这一条进行归约。那么只需要在k处（目前最小空闲下标）处放上op，再更新POST数组目前最小空闲下标k为k+1即可。

```python
E -> E1 op E2	|{POST[k]:=op;k:=k+1}
E -> (E1)	|{}
E->id	|{POST[k]:=id;k:=k+1}
```

### AST中间语言

略，见语法制导翻译部分。

### DAG中间语言

DAG与AST的区别是：DAG的每个结点可能有多个父节点。

DAG是对AST的一种优化，**是基于AST改造而来。**它遵循如下方式构建。

- 内部节点代表操作符，其孩子是该操作符的操作数
- 每个子表达式，DAG中都有一个结点对应。但是DAG中的一个结点可能对应源表达式中多个完全相同的子表达式（公共子表达式）。换言之，公共子表达式对应的DAG结点可能有多个父节点。如下图所示。

<img src="https://linton-pics.oss-cn-beijing.aliyuncs.com/uPic/image-20220617172630947.png" alt="image-20220617172630947" style="zoom:25%;" />

例如上图中，DAG把AST中的下面两棵子树合并成了同一个子图，这就消除了一定的冗余（可以实现后端代码优化）。而且这启发我们：DAG可以看做是在AST的基础上进行的改造，并不是新东西。

注意，边都是父节点指向子节点的，只是这里省略。

在代码实现上，每个符号仍然都有nptr属性。在构建过程中，也利用前面所说的mknode、mkleaf语义规则，其用法不变。
