---
title: 做个编译器——预测式语法分析
date: 2022-06-02 15:13:06
tags: [笔记]
categories: []
summary: 它通过look-ahead的方式来“预测”要使用哪个产生式，而不是瞎蒙，并能保证不发生回溯，从而提升效率。



---



## General

类似于递归下降分析，预测式语法分析也是尝试去寻找合适的产生式来进行语法分析。

但是，它通过look-ahead的方式来“预测”要使用哪个产生式，而不是瞎蒙，并能保证不发生回溯（这是他的一大优点），从而提升效率。

> 说实话，有点像强化学习😅，那张分析表就是Q-Table，只不过是人工编写的😅。

## LL(1)分析法

> LL(1)分析法用于自顶向下的语法分析。它的过程和递归下降是一样的，但是不需要进行回溯了。因为在给定的state下，在给定的输入下，LL(1)分析表只会**对最左的非终结符**给出一个可用的产生式预测，如果不存在这样的预测就必然可以直接Rejected了，并不存在递归下降分析里面那种“逐个尝试，失败回退”的情况了，于是可以大大提升效率。

#### 命名的由来

- 第一个L称为“left-to-right”，即从左向右来读入输入串。
- 第二个L称为“leftmost derivation”，即采用最左推导。
- LL(k)的k代表向前看k个token来进行预测。在生产实践中，k并不是越大越好，一般取1比较好。

#### 消除公共左因子

仍然考虑这个熟悉的文法：

<img src="https://linton-pics.oss-cn-beijing.aliyuncs.com/uPic/image-20220610211103930.png" alt="image-20220610211103930" style="zoom:33%;" />

如果采用LL(1)，那就是look-ahead一个token。例如当前的状态是T，下一个token是`int`，那么实际上无法决定是使用`T->int`还是`T->int*T`，因为仅凭借一个look-ahead是无法区分二者的。

出现这个问题的原因是：产生式`T->int`和`T->int*T`具有公共左因子`int`。

因此，如果尝试使用LL(1)分析法，就要消除掉这个公共左因子，于是可以把T的产生式转换为如下形式：

```python
T -> intY|(E)
Y -> ε|*T
```

同理，E的产生式也有这个问题，所以可以转化为：

```
E -> TX
X -> ε|+E
```

也就是把公共左因子的生成单独提出来作为一个产生式。

#### LL(1)分析表

行名是非终结符，列名是终结符（包括结束标记`$`），元素是当前文法符号栈顶是非终结符的情况下，有输入串指针指向的token的情况，应当采取的产生式的**右部**。如图。

<img src="https://linton-pics.oss-cn-beijing.aliyuncs.com/uPic/image-20220610212117217.png" alt="image-20220610212117217" style="zoom:33%;" />

特别地，如果某单元格[S,t]处没有元素，意思是文法符号栈顶（即最左非终结符）是S的情况下，如果遇到了t的输入，即可一票否决，直接Rejected。

#### LL(1)和递归下降法的区别

- 每次只考虑最左非终结符（最左推导）
- 每次通过考虑下一个输入token（或者说是当前需要处理的token，看你怎么理解了，都是一个意思），查LL(1)分析表的[S,t]位置从而精准指导产生式的选择；而在递归下降法中并不会参考下一个输入token进行产生式的选择，而是遍历尝试，从而导致大量的回溯，非常慢。

#### LL(1)文法符号栈

- 文法符号栈的栈顶是如下元素
	- 如果是非终结符：则是**语法树叶结点的**最左边的非终结符，正在等待被利用产生式加以展开
	- 如果是终结符：则是**语法树叶结点的**最左边的**未被匹配的**终结符，正在等待被匹配

#### LL(1)分析过程

- 初始化文法符号栈
	- `$`入栈，表示栈底；然后开始符号S入栈，等待分析。（可以认为语法树的初始叶结点实际上就是那个根。）
- 如果文法符号栈顶是非终结符X
	- 出栈
	- 查表`[X,*next]`，如果不是空单元格，则压入单元格内容（实际上是对应的产生式的右部）
	- 如果是空单元格，Rejected
- 如果文法符号栈顶是终结符t
	- 出栈
	- 匹配`*next`和t，并且让next向前移动
	- 如果匹配失败，Rejected
- Rejected
	- 非终结符查表，如果碰到空单元格，一票否决；
	- 终结符匹配`*next`，如果失败，一票否决；
- Accepted
	- 如果输入串只剩下`$`了，并且文法符号栈只剩下`$`了，那么AC。
	- 值得注意的是，“输入串只剩下`$`了”的意思是输入流已经读入到末尾了；“文法符号栈空了”的意思是语法树的叶结点都匹配完成了。这是完全符合递归下降定义的。

<img src="https://linton-pics.oss-cn-beijing.aliyuncs.com/uPic/image-20220610214010476.png" alt="image-20220610214010476" style="zoom:33%;" />

这是分析过程的两个瞬间。可以看到，文法符号栈的内容就是各叶结点。因此栈顶的内容就是最左边的未进行匹配的那个叶结点，或是最左边的非终结符。

例如最后一行，因为`int`、`*`都已经完事，但是T、X还没处理，所以反映在了栈中。

> 容易观察到，凡是已经被弹出的部分，例如图中的`int`、`*`，都是终结符。换句话说，只要是比文法符号栈栈顶还要靠左的叶结点内容，必然是终结符，而且都匹配完毕。

#### First集合和Follow集合的概念

考虑当前文法符号栈顶是A，如果这个时候来了输入token t，如何预测采用的产生式？

我们的目的在于让文法符号栈中产生t，来与这个输入的t来对对碰，从而match掉这个输入t。那么如何做到呢？

假设采用产生式A->α。

如果有`α->tβ`成立（可以是星号推导），那么A就可以替换成tβ，替换之后t就变成了文法符号栈栈顶了。（如果太抽象，可以看LL1分析过程的例子图，看看发生替换的时候，文法符号栈如何变化。）既然t是栈顶了，则下一次即可直接进行对对碰了。

在这种方式中，α可以产生一个t出来，并且放在文法符号栈的**first position**，**于是得名First Set**，First集合。也就是t属于**α的**First集合。

如果有A->α，但是α不能推出t在first position的式子怎么办？这个时候可以利用恋爱中的“得不到就毁灭”恶习，直接把A给灭了，让别人去接这个锅，事情不就解决了？因为A留着也没用，在这里挡道。

因此，如果有A->α，α->ε（可以是星号推导），且S->βAtδ，那么A可以在推出α后再推出ε，从而从文法符号栈中原地消失。这样一来，本来A是符号栈栈顶，现在A消失了，t就变成栈顶了，就可以和输入的token t对对碰了，完成任务。

在这个过程中，t是紧跟着A的，称为follow。因此说t属于**A的**Follow集合。

注意这两个定义，一个是α的first集合，一个是A的follow集合。他们的对象不一样。
